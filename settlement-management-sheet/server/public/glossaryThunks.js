import{aW as l,bJ as u,a2 as i,bK as S,bL as A,bM as w,bN as f,an as b,ao as G,bO as m,a1 as I,ak as h,bP as p,at as N,bQ as E,bR as x,bu as B,v as $,bS as M,bT as v,bU as F,bV as O,bp as P,bW as K}from"./main.js";function W(){return async(o,r)=>{try{if(r().glossary.glossaries.edit.allIds.length>0)return;const e=await l.getGlossaries(),s=r().glossary.glossaries.edit.byId;console.log(e),e.forEach(a=>{s[a.id]||o(u({glossaryId:a.id,name:a.name,description:a.description,genre:a.genre,subGenre:a.subGenre,integrationState:a.integrationState,theme:a.theme}))})}catch(t){console.error("Error fetching glossaries:",t),o(i({message:"Error fetching glossaries. Try again later.",type:"error",duration:3e3}))}}}function z({glossaryId:o}){return async(r,t)=>{try{const e=t().glossary.glossaries.edit.byId[o];if(e.hydrated)return;const s=await l.getNodes({glossaryId:o}),a=e.renderState,{nodeMap:n,roots:d,renderState:y}=S(s,a);r(A({glossaryId:o,nodes:n,structure:s,renderState:y}))}catch(e){console.error("Error fetching glossary nodes:",e),r(i({message:"Error fetching glossary structure. Try again later.",type:"error",duration:3e3}))}}}function C({node:o}){return async r=>{try{const t=o,e=await l.getEntryById({nodeId:t.id,entryType:t.entryType});r(w({glossaryId:t.glossaryId,entryId:t.id,entryData:e}))}catch(t){console.error("Error fetching glossary node:",t),r(i({message:"Error fetching glossary node. Try again later.",type:"error",duration:3e3}))}}}function J({id:o,name:r,description:t,genre:e,subGenre:s}){return async a=>{try{const n=await l.createGlossary({id:o,name:r,description:t,genre:e,subGenre:s});a(u({glossaryId:n.id,name:n.name,description:n.description,genre:n.genre,subGenre:n.subGenre}))}catch(n){console.error("Error creating glossary:",n),a(i({message:"Error creating glossary. Try again later.",type:"error",duration:3e3}))}}}function L({node:o}){return async r=>{const{id:t,name:e,entryType:s,parentId:a,glossaryId:n}=o;console.log("Creating node and section"),r(f({glossaryId:n,nodeId:t,nodeData:o}));try{await l.createNodeAndSection({id:t,name:e,entryType:s,fileType:"section",parentId:a,glossaryId:n,entryData:o}),r(b({glossaryId:n,nodeId:t})),a&&r(G({glossaryId:n,nodeId:a,expanded:!0}))}catch(d){console.error("Error adding node:",d),r(m({glossaryId:n,nodeId:t})),r(i({message:"Error adding entry. Try again later.",type:"error",duration:3e3}))}}}function Q({node:o}){return async(r,t)=>{const{id:e,glossaryId:s,fileType:a,name:n,entryType:d}=o,y=I.cloneDeep(h(s,e)(t()));if(y.name===n){console.warn("No change in name, skipping update.");return}console.log({...y,name:n},"updating node to:"),r(p({glossaryId:s,nodeId:e,nodeData:{...y,name:n}}));try{await l.renameNodeAndEntry({id:e,name:n,entryType:d,fileType:a})}catch(c){console.error("Error renaming node:",c),r(p({glossaryId:s,nodeId:e,nodeData:{...y}})),r(i({message:"Error renaming entry. Try again later.",type:"error",duration:3e3}))}}}function R({id:o,name:r,description:t,genre:e,subGenre:s}){return async a=>{a(u({glossaryId:o,name:r,description:t,genre:e,subGenre:s,integrationState:{},theme:"default"})),a(N({glossaryId:o}))}}const k=o=>(r,t)=>{const{left:e,right:s}=t().tabs,a=y=>(y==="left"?e:s).order.find(g=>(y==="left"?e.data[g]:s.data[g]).id===o),n=a("left");if(n){r(E({tabId:n,side:"left"}));return}const d=a("right");if(d){r(E({tabId:d,side:"right"}));return}console.error("Tab not found in tabThunks: findAndDeleteTab:",o)};function U({node:o}){return async(r,t)=>{const{id:e,entryType:s,fileType:a,glossaryId:n}=o,d=I.cloneDeep(h(n,e)(t()));try{await l.deleteEntry({id:e,entryType:s,fileType:a,glossaryId:n}),r(m({glossaryId:n,nodeId:e})),r(k(e)),r(i({message:`${d.name} successfully deleted.`,type:"success",duration:3e3,component:void 0,props:{}}))}catch(y){console.error("Error removing node:",y),r(f({glossaryId:n,nodeId:e,nodeData:d})),r(i({message:"Error removing entry. Try again later.",type:"error",duration:3e3}))}}}function V({glossaryId:o,entryId:r,property:t,inheritanceMap:e}){return async(s,a)=>{try{const d=(await l.getOptionsByProperty({property:t,inheritanceMap:e})).results;s(x({glossaryId:o,entryId:r,property:t,options:d}))}catch(n){console.error("Error fetching options by property:",n),s(i({message:"Error fetching options. Try again later.",type:"error",duration:3e3}))}}}function j(){return async(o,r)=>{const t=r().glossary.activeGlossaryId;if(!t){o(i({message:"No active glossary selected.",type:"error",duration:3e3}));return}const e=r().glossary.glossaries[t];if(!e){o(i({message:"Active glossary not found.",type:"error",duration:3e3}));return}o(B({name:e.name,mode:"edit",tool:"editGlossary",tabType:"glossary",id:e.id,tabId:$(),scroll:0,activate:!0,disableMenu:!0,preventSplit:!1}))}}function q({node:o}){return async r=>{const{id:t,name:e,entryType:s,parentId:a,glossaryId:n}=o;r(f({glossaryId:n,nodeId:t,nodeData:o}));try{await l.createNodeAndDetail({id:t,name:e,entryType:s,fileType:"detail",parentId:a,glossaryId:n,entryData:o}),r(b({glossaryId:n,nodeId:t})),a&&r(G({glossaryId:n,nodeId:a,expanded:!0}))}catch(d){console.error("Error adding node:",d),r(m({glossaryId:n,nodeId:t})),r(i({message:"Error adding entry. Try again later.",type:"error",duration:3e3}))}}}function H({glossaryId:o,side:r}){return async(t,e)=>{try{const s=e().glossary.glossaries.edit.byId[o];if(!s)throw new Error(`Glossary with ID ${o} not found`);t(k(o)),await l.deleteGlossary({glossaryId:o}),t(M({glossaryId:o})),t(N({glossaryId:null})),t(i({message:`${s.name} successfully deleted.`,type:"success",duration:3e3,component:void 0,props:{}}))}catch(s){console.error("Error removing node:",s),t(i({message:"Error removing glossary. Try again later.",type:"error",duration:3e3}))}}}function X({glossaryId:o,entryId:r,content:t}){return async(e,s)=>{const n=s().glossary.glossaries.edit.byId[o];if(!n){e(i({message:"Glossary not found.",type:"error",duration:3e3}));return}const d=n.entries[r];if(!d){e(i({message:"Entry not found.",type:"error",duration:3e3}));return}try{e(v({glossaryId:o,entryId:r,content:t}))}catch(y){console.error("Error updating entry:",y),e(i({message:`Error updating ${d.name}. Try again later.`,type:"error",duration:3e3}))}}}const T={politics:{nations:[],settlements:[],factions:[],locations:[],resources:{},population:{},economy:{},cultures:{},customFields:{}},history:{events:[],flags:{},history:{},customFields:{},historyDataString:""},geography:{climates:[],terrain:[],regions:[],landmarks:[],customFields:{}},relationships:{allies:[],enemies:[],relationships:{},notoriety:{},influence:{},customFields:{}},custom:null};function Y({glossaryId:o,entryId:r,entryType:t,subModel:e}){return async s=>{try{const a=await l.getEntrySubModel({id:r,entryType:t,subModel:e});if(a)s(v({glossaryId:o,entryId:r,content:{[e]:a}}));else{if(!T[e]){console.error(`No ephemeral model found for subModel: ${e}`);return}s(F({glossaryId:o,entryId:r,subModel:e,data:{...T[e]}}))}}catch(a){console.error("Error fetching glossary node:",a),s(i({message:"Error fetching glossary node. Try again later.",type:"error",duration:3e3}))}}}function Z({glossaryId:o,tabId:r,entryId:t,subModel:e,keypath:s,data:a}){return async(n,d)=>{const c=d().glossary.glossaries.edit.byId[o];if(!c){n(i({message:"Glossary not found.",type:"error",duration:3e3}));return}const g=c.entries[t];if(!g){n(i({message:"Entry not found.",type:"error",duration:3e3}));return}try{n(O({glossaryId:o,entryId:t,subModel:e,keypath:s,data:a})),n(P({tabId:r,keypath:`entries.${t}.${e}.${s}`}))}catch(D){console.error("Error updating entry:",D),n(i({message:`Error updating ${g.name}. Try again later.`,type:"error",duration:3e3}))}}}const ee={getGlossaries:W,getNodes:z,createGlossary:J,createNodeAndSection:L,createNodeAndDetail:q,renameNodeAndEntry:Q,deleteEntry:U,updateGlossary:K,addAndActivateGlossary:R,getEntryById:C,updateEntryById:X,getOptionsByProperty:V,openEditGlossary:j,deleteGlossary:H,getEntrySubModel:Y,updateEntrySubModelById:Z};export{ee as t};
